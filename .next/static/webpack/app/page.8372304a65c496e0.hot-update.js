"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/use-scheduling.ts":
/*!*********************************!*\
  !*** ./hooks/use-scheduling.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useScheduling: () => (/* binding */ useScheduling)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_scheduling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/scheduling */ \"(app-pages-browser)/./lib/scheduling.ts\");\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/db */ \"(app-pages-browser)/./lib/db.ts\");\n/* __next_internal_client_entry_do_not_use__ useScheduling auto */ \n\n\nfunction useScheduling() {\n    const [scheduleEntries, setScheduleEntries] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    // Load schedule entries from IndexedDB on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useScheduling.useEffect\": ()=>{\n            const load = {\n                \"useScheduling.useEffect.load\": async ()=>{\n                    try {\n                        const all = await (0,_lib_db__WEBPACK_IMPORTED_MODULE_2__.getAllSchedules)();\n                        setScheduleEntries(all);\n                    } catch (e) {\n                        console.error('Failed to load schedules', e);\n                    } finally{\n                        setIsLoading(false);\n                    }\n                }\n            }[\"useScheduling.useEffect.load\"];\n            load();\n        }\n    }[\"useScheduling.useEffect\"], []);\n    const persist = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useScheduling.useCallback[persist]\": async (entry)=>{\n            await (0,_lib_db__WEBPACK_IMPORTED_MODULE_2__.upsertSchedule)(entry);\n        }\n    }[\"useScheduling.useCallback[persist]\"], []);\n    // Rate a problem and update its schedule\n    const rateProblem = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useScheduling.useCallback[rateProblem]\": async (problemId, rating)=>{\n            setScheduleEntries({\n                \"useScheduling.useCallback[rateProblem]\": (prev)=>{\n                    const existingEntry = prev.find({\n                        \"useScheduling.useCallback[rateProblem]\": (entry)=>entry.problemId === problemId\n                    }[\"useScheduling.useCallback[rateProblem]\"]) || null;\n                    const updatedEntry = (0,_lib_scheduling__WEBPACK_IMPORTED_MODULE_1__.updateScheduleEntry)(existingEntry, problemId, rating);\n                    // Fire-and-forget persist\n                    persist(updatedEntry);\n                    const newEntries = existingEntry ? prev.map({\n                        \"useScheduling.useCallback[rateProblem]\": (entry)=>entry.problemId === problemId ? updatedEntry : entry\n                    }[\"useScheduling.useCallback[rateProblem]\"]) : [\n                        ...prev,\n                        updatedEntry\n                    ];\n                    return newEntries;\n                }\n            }[\"useScheduling.useCallback[rateProblem]\"]);\n        }\n    }[\"useScheduling.useCallback[rateProblem]\"], [\n        persist\n    ]);\n    // Snooze a problem for 7 days\n    const snoozeProblemById = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useScheduling.useCallback[snoozeProblemById]\": async (problemId)=>{\n            setScheduleEntries({\n                \"useScheduling.useCallback[snoozeProblemById]\": (prev)=>{\n                    const entry = prev.find({\n                        \"useScheduling.useCallback[snoozeProblemById].entry\": (e)=>e.problemId === problemId\n                    }[\"useScheduling.useCallback[snoozeProblemById].entry\"]);\n                    if (!entry) return prev;\n                    const updated = (0,_lib_scheduling__WEBPACK_IMPORTED_MODULE_1__.snoozeProblem)(entry);\n                    persist(updated);\n                    return prev.map({\n                        \"useScheduling.useCallback[snoozeProblemById]\": (e)=>e.problemId === problemId ? updated : e\n                    }[\"useScheduling.useCallback[snoozeProblemById]\"]);\n                }\n            }[\"useScheduling.useCallback[snoozeProblemById]\"]);\n        }\n    }[\"useScheduling.useCallback[snoozeProblemById]\"], [\n        persist\n    ]);\n    // Get problems due for review today\n    const getDueProblemsForToday = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useScheduling.useCallback[getDueProblemsForToday]\": ()=>{\n            return (0,_lib_scheduling__WEBPACK_IMPORTED_MODULE_1__.getDueProblems)(scheduleEntries, {\n                min: 3,\n                max: 5\n            });\n        }\n    }[\"useScheduling.useCallback[getDueProblemsForToday]\"], [\n        scheduleEntries\n    ]);\n    // Get schedule entry for a specific problem\n    const getScheduleEntry = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useScheduling.useCallback[getScheduleEntry]\": (problemId)=>{\n            return scheduleEntries.find({\n                \"useScheduling.useCallback[getScheduleEntry]\": (entry)=>entry.problemId === problemId\n            }[\"useScheduling.useCallback[getScheduleEntry]\"]);\n        }\n    }[\"useScheduling.useCallback[getScheduleEntry]\"], [\n        scheduleEntries\n    ]);\n    // Get formatted time until due for a problem\n    const getTimeUntilDue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useScheduling.useCallback[getTimeUntilDue]\": (problemId)=>{\n            const entry = getScheduleEntry(problemId);\n            if (!entry) return \"Not scheduled\";\n            return (0,_lib_scheduling__WEBPACK_IMPORTED_MODULE_1__.formatTimeUntilDue)(entry.nextDueAt);\n        }\n    }[\"useScheduling.useCallback[getTimeUntilDue]\"], [\n        getScheduleEntry\n    ]);\n    return {\n        scheduleEntries,\n        rateProblem,\n        snoozeProblemById,\n        getDueProblemsForToday,\n        getScheduleEntry,\n        getTimeUntilDue,\n        isLoading\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1zY2hlZHVsaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O21FQUV3RDtBQU8vQjtBQUN5RDtBQVkzRSxTQUFTVTtJQUNkLE1BQU0sQ0FBQ0MsaUJBQWlCQyxtQkFBbUIsR0FBR1osK0NBQVFBLENBQWtCLEVBQUU7SUFDMUUsTUFBTSxDQUFDYSxXQUFXQyxhQUFhLEdBQUdkLCtDQUFRQSxDQUFDO0lBRTNDLGdEQUFnRDtJQUNoREUsZ0RBQVNBO21DQUFDO1lBQ1IsTUFBTWE7Z0RBQU87b0JBQ1gsSUFBSTt3QkFDRixNQUFNQyxNQUFNLE1BQU1SLHdEQUFlQTt3QkFDakNJLG1CQUFtQkk7b0JBQ3JCLEVBQUUsT0FBT0MsR0FBRzt3QkFDVkMsUUFBUUMsS0FBSyxDQUFDLDRCQUE0QkY7b0JBQzVDLFNBQVU7d0JBQ1JILGFBQWE7b0JBQ2Y7Z0JBQ0Y7O1lBQ0FDO1FBQ0Y7a0NBQUcsRUFBRTtJQUVMLE1BQU1LLFVBQVVuQixrREFBV0E7OENBQUMsT0FBT29CO1lBQ2pDLE1BQU1aLHVEQUFjQSxDQUFDWTtRQUN2Qjs2Q0FBRyxFQUFFO0lBRUwseUNBQXlDO0lBQ3pDLE1BQU1DLGNBQWNyQixrREFBV0E7a0RBQUMsT0FBT3NCLFdBQW1CQztZQUN4RFo7MERBQW1CYSxDQUFBQTtvQkFDakIsTUFBTUMsZ0JBQWdCRCxLQUFLRSxJQUFJO2tFQUFDTixDQUFBQSxRQUFTQSxNQUFNRSxTQUFTLEtBQUtBO29FQUFjO29CQUMzRSxNQUFNSyxlQUFlekIsb0VBQW1CQSxDQUFDdUIsZUFBZUgsV0FBV0M7b0JBQ25FLDBCQUEwQjtvQkFDMUJKLFFBQVFRO29CQUNSLE1BQU1DLGFBQWFILGdCQUNmRCxLQUFLSyxHQUFHO2tFQUFDVCxDQUFBQSxRQUFTQSxNQUFNRSxTQUFTLEtBQUtBLFlBQVlLLGVBQWVQO21FQUNqRTsyQkFBSUk7d0JBQU1HO3FCQUFhO29CQUMzQixPQUFPQztnQkFDVDs7UUFDRjtpREFBRztRQUFDVDtLQUFRO0lBRVosOEJBQThCO0lBQzlCLE1BQU1XLG9CQUFvQjlCLGtEQUFXQTt3REFBQyxPQUFPc0I7WUFDM0NYO2dFQUFtQmEsQ0FBQUE7b0JBQ2pCLE1BQU1KLFFBQVFJLEtBQUtFLElBQUk7OEVBQUNWLENBQUFBLElBQUtBLEVBQUVNLFNBQVMsS0FBS0E7O29CQUM3QyxJQUFJLENBQUNGLE9BQU8sT0FBT0k7b0JBQ25CLE1BQU1PLFVBQVUzQiw4REFBV0EsQ0FBQ2dCO29CQUM1QkQsUUFBUVk7b0JBQ1IsT0FBT1AsS0FBS0ssR0FBRzt3RUFBQ2IsQ0FBQUEsSUFBS0EsRUFBRU0sU0FBUyxLQUFLQSxZQUFZUyxVQUFVZjs7Z0JBQzdEOztRQUNGO3VEQUFHO1FBQUNHO0tBQVE7SUFFWixvQ0FBb0M7SUFDcEMsTUFBTWEseUJBQXlCaEMsa0RBQVdBOzZEQUFDO1lBQ3pDLE9BQU9LLCtEQUFjQSxDQUFDSyxpQkFBaUI7Z0JBQUV1QixLQUFLO2dCQUFHQyxLQUFLO1lBQUU7UUFDMUQ7NERBQUc7UUFBQ3hCO0tBQWdCO0lBRXBCLDRDQUE0QztJQUM1QyxNQUFNeUIsbUJBQW1CbkMsa0RBQVdBO3VEQUFDLENBQUNzQjtZQUNwQyxPQUFPWixnQkFBZ0JnQixJQUFJOytEQUFDTixDQUFBQSxRQUFTQSxNQUFNRSxTQUFTLEtBQUtBOztRQUMzRDtzREFBRztRQUFDWjtLQUFnQjtJQUVwQiw2Q0FBNkM7SUFDN0MsTUFBTTBCLGtCQUFrQnBDLGtEQUFXQTtzREFBQyxDQUFDc0I7WUFDbkMsTUFBTUYsUUFBUWUsaUJBQWlCYjtZQUMvQixJQUFJLENBQUNGLE9BQU8sT0FBTztZQUNuQixPQUFPZCxtRUFBa0JBLENBQUNjLE1BQU1pQixTQUFTO1FBQzNDO3FEQUFHO1FBQUNGO0tBQWlCO0lBRXJCLE9BQU87UUFDTHpCO1FBQ0FXO1FBQ0FTO1FBQ0FFO1FBQ0FHO1FBQ0FDO1FBQ0F4QjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kaWdpdGFsZmxvd2VyL0Rlc2t0b3Avb3JiaXMvaG9va3MvdXNlLXNjaGVkdWxpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFxuICBTY2hlZHVsZUVudHJ5LCBcbiAgdXBkYXRlU2NoZWR1bGVFbnRyeSwgXG4gIHNub296ZVByb2JsZW0gYXMgc25vb3plRW50cnksIFxuICBnZXREdWVQcm9ibGVtcyxcbiAgZm9ybWF0VGltZVVudGlsRHVlLFxufSBmcm9tICdAL2xpYi9zY2hlZHVsaW5nJ1xuaW1wb3J0IHsgZ2V0QWxsU2NoZWR1bGVzLCBnZXRTY2hlZHVsZUJ5UHJvYmxlbUlkLCB1cHNlcnRTY2hlZHVsZSB9IGZyb20gJ0AvbGliL2RiJ1xuXG5pbnRlcmZhY2UgVXNlU2NoZWR1bGluZ1JldHVybiB7XG4gIHNjaGVkdWxlRW50cmllczogU2NoZWR1bGVFbnRyeVtdXG4gIHJhdGVQcm9ibGVtOiAocHJvYmxlbUlkOiBzdHJpbmcsIHJhdGluZzogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XG4gIHNub296ZVByb2JsZW1CeUlkOiAocHJvYmxlbUlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD5cbiAgZ2V0RHVlUHJvYmxlbXNGb3JUb2RheTogKCkgPT4gU2NoZWR1bGVFbnRyeVtdXG4gIGdldFNjaGVkdWxlRW50cnk6IChwcm9ibGVtSWQ6IHN0cmluZykgPT4gU2NoZWR1bGVFbnRyeSB8IHVuZGVmaW5lZFxuICBnZXRUaW1lVW50aWxEdWU6IChwcm9ibGVtSWQ6IHN0cmluZykgPT4gc3RyaW5nXG4gIGlzTG9hZGluZzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2NoZWR1bGluZygpOiBVc2VTY2hlZHVsaW5nUmV0dXJuIHtcbiAgY29uc3QgW3NjaGVkdWxlRW50cmllcywgc2V0U2NoZWR1bGVFbnRyaWVzXSA9IHVzZVN0YXRlPFNjaGVkdWxlRW50cnlbXT4oW10pXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuXG4gIC8vIExvYWQgc2NoZWR1bGUgZW50cmllcyBmcm9tIEluZGV4ZWREQiBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhbGwgPSBhd2FpdCBnZXRBbGxTY2hlZHVsZXMoKVxuICAgICAgICBzZXRTY2hlZHVsZUVudHJpZXMoYWxsIGFzIHVua25vd24gYXMgU2NoZWR1bGVFbnRyeVtdKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBzY2hlZHVsZXMnLCBlKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKVxuICAgICAgfVxuICAgIH1cbiAgICBsb2FkKClcbiAgfSwgW10pXG5cbiAgY29uc3QgcGVyc2lzdCA9IHVzZUNhbGxiYWNrKGFzeW5jIChlbnRyeTogU2NoZWR1bGVFbnRyeSkgPT4ge1xuICAgIGF3YWl0IHVwc2VydFNjaGVkdWxlKGVudHJ5IGFzIGFueSlcbiAgfSwgW10pXG5cbiAgLy8gUmF0ZSBhIHByb2JsZW0gYW5kIHVwZGF0ZSBpdHMgc2NoZWR1bGVcbiAgY29uc3QgcmF0ZVByb2JsZW0gPSB1c2VDYWxsYmFjayhhc3luYyAocHJvYmxlbUlkOiBzdHJpbmcsIHJhdGluZzogbnVtYmVyKSA9PiB7XG4gICAgc2V0U2NoZWR1bGVFbnRyaWVzKHByZXYgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHByZXYuZmluZChlbnRyeSA9PiBlbnRyeS5wcm9ibGVtSWQgPT09IHByb2JsZW1JZCkgfHwgbnVsbFxuICAgICAgY29uc3QgdXBkYXRlZEVudHJ5ID0gdXBkYXRlU2NoZWR1bGVFbnRyeShleGlzdGluZ0VudHJ5LCBwcm9ibGVtSWQsIHJhdGluZylcbiAgICAgIC8vIEZpcmUtYW5kLWZvcmdldCBwZXJzaXN0XG4gICAgICBwZXJzaXN0KHVwZGF0ZWRFbnRyeSlcbiAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSBleGlzdGluZ0VudHJ5IFxuICAgICAgICA/IHByZXYubWFwKGVudHJ5ID0+IGVudHJ5LnByb2JsZW1JZCA9PT0gcHJvYmxlbUlkID8gdXBkYXRlZEVudHJ5IDogZW50cnkpXG4gICAgICAgIDogWy4uLnByZXYsIHVwZGF0ZWRFbnRyeV1cbiAgICAgIHJldHVybiBuZXdFbnRyaWVzXG4gICAgfSlcbiAgfSwgW3BlcnNpc3RdKVxuXG4gIC8vIFNub296ZSBhIHByb2JsZW0gZm9yIDcgZGF5c1xuICBjb25zdCBzbm9vemVQcm9ibGVtQnlJZCA9IHVzZUNhbGxiYWNrKGFzeW5jIChwcm9ibGVtSWQ6IHN0cmluZykgPT4ge1xuICAgIHNldFNjaGVkdWxlRW50cmllcyhwcmV2ID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gcHJldi5maW5kKGUgPT4gZS5wcm9ibGVtSWQgPT09IHByb2JsZW1JZClcbiAgICAgIGlmICghZW50cnkpIHJldHVybiBwcmV2XG4gICAgICBjb25zdCB1cGRhdGVkID0gc25vb3plRW50cnkoZW50cnkpXG4gICAgICBwZXJzaXN0KHVwZGF0ZWQpXG4gICAgICByZXR1cm4gcHJldi5tYXAoZSA9PiBlLnByb2JsZW1JZCA9PT0gcHJvYmxlbUlkID8gdXBkYXRlZCA6IGUpXG4gICAgfSlcbiAgfSwgW3BlcnNpc3RdKVxuXG4gIC8vIEdldCBwcm9ibGVtcyBkdWUgZm9yIHJldmlldyB0b2RheVxuICBjb25zdCBnZXREdWVQcm9ibGVtc0ZvclRvZGF5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBnZXREdWVQcm9ibGVtcyhzY2hlZHVsZUVudHJpZXMsIHsgbWluOiAzLCBtYXg6IDUgfSlcbiAgfSwgW3NjaGVkdWxlRW50cmllc10pXG5cbiAgLy8gR2V0IHNjaGVkdWxlIGVudHJ5IGZvciBhIHNwZWNpZmljIHByb2JsZW1cbiAgY29uc3QgZ2V0U2NoZWR1bGVFbnRyeSA9IHVzZUNhbGxiYWNrKChwcm9ibGVtSWQ6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiBzY2hlZHVsZUVudHJpZXMuZmluZChlbnRyeSA9PiBlbnRyeS5wcm9ibGVtSWQgPT09IHByb2JsZW1JZClcbiAgfSwgW3NjaGVkdWxlRW50cmllc10pXG5cbiAgLy8gR2V0IGZvcm1hdHRlZCB0aW1lIHVudGlsIGR1ZSBmb3IgYSBwcm9ibGVtXG4gIGNvbnN0IGdldFRpbWVVbnRpbER1ZSA9IHVzZUNhbGxiYWNrKChwcm9ibGVtSWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZ2V0U2NoZWR1bGVFbnRyeShwcm9ibGVtSWQpXG4gICAgaWYgKCFlbnRyeSkgcmV0dXJuIFwiTm90IHNjaGVkdWxlZFwiXG4gICAgcmV0dXJuIGZvcm1hdFRpbWVVbnRpbER1ZShlbnRyeS5uZXh0RHVlQXQpXG4gIH0sIFtnZXRTY2hlZHVsZUVudHJ5XSlcblxuICByZXR1cm4ge1xuICAgIHNjaGVkdWxlRW50cmllcyxcbiAgICByYXRlUHJvYmxlbSxcbiAgICBzbm9vemVQcm9ibGVtQnlJZCxcbiAgICBnZXREdWVQcm9ibGVtc0ZvclRvZGF5LFxuICAgIGdldFNjaGVkdWxlRW50cnksXG4gICAgZ2V0VGltZVVudGlsRHVlLFxuICAgIGlzTG9hZGluZ1xuICB9XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVwZGF0ZVNjaGVkdWxlRW50cnkiLCJzbm9vemVQcm9ibGVtIiwic25vb3plRW50cnkiLCJnZXREdWVQcm9ibGVtcyIsImZvcm1hdFRpbWVVbnRpbER1ZSIsImdldEFsbFNjaGVkdWxlcyIsInVwc2VydFNjaGVkdWxlIiwidXNlU2NoZWR1bGluZyIsInNjaGVkdWxlRW50cmllcyIsInNldFNjaGVkdWxlRW50cmllcyIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImxvYWQiLCJhbGwiLCJlIiwiY29uc29sZSIsImVycm9yIiwicGVyc2lzdCIsImVudHJ5IiwicmF0ZVByb2JsZW0iLCJwcm9ibGVtSWQiLCJyYXRpbmciLCJwcmV2IiwiZXhpc3RpbmdFbnRyeSIsImZpbmQiLCJ1cGRhdGVkRW50cnkiLCJuZXdFbnRyaWVzIiwibWFwIiwic25vb3plUHJvYmxlbUJ5SWQiLCJ1cGRhdGVkIiwiZ2V0RHVlUHJvYmxlbXNGb3JUb2RheSIsIm1pbiIsIm1heCIsImdldFNjaGVkdWxlRW50cnkiLCJnZXRUaW1lVW50aWxEdWUiLCJuZXh0RHVlQXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-scheduling.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/db.ts":
/*!*******************!*\
  !*** ./lib/db.ts ***!
  \*******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAllProblems: () => (/* binding */ getAllProblems),\n/* harmony export */   getAllSchedules: () => (/* binding */ getAllSchedules),\n/* harmony export */   getDB: () => (/* binding */ getDB),\n/* harmony export */   getProblemById: () => (/* binding */ getProblemById),\n/* harmony export */   getScheduleByProblemId: () => (/* binding */ getScheduleByProblemId),\n/* harmony export */   putProblems: () => (/* binding */ putProblems),\n/* harmony export */   upsertSchedule: () => (/* binding */ upsertSchedule)\n/* harmony export */ });\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! idb */ \"(app-pages-browser)/./node_modules/idb/build/index.js\");\n\nlet dbPromise = null;\nasync function getDB() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_0__.openDB)('orbis-db', 1, {\n            upgrade (db) {\n                if (!db.objectStoreNames.contains('problems')) {\n                    const problems = db.createObjectStore('problems', {\n                        keyPath: 'id'\n                    });\n                    problems.createIndex('by_createdAt', 'createdAt');\n                }\n                if (!db.objectStoreNames.contains('schedules')) {\n                    const schedules = db.createObjectStore('schedules', {\n                        keyPath: 'problemId'\n                    });\n                    schedules.createIndex('by_nextDueAt', 'nextDueAt');\n                }\n            }\n        });\n    }\n    return dbPromise;\n}\n// Problems CRUD\nasync function putProblems(records) {\n    const db = await getDB();\n    const tx = db.transaction('problems', 'readwrite');\n    const store = tx.objectStore('problems');\n    for (const rec of records){\n        await store.put(rec);\n    }\n    await tx.done;\n}\nasync function getAllProblems() {\n    const db = await getDB();\n    return db.getAll('problems');\n}\nasync function getProblemById(id) {\n    const db = await getDB();\n    return db.get('problems', id);\n}\n// Schedules CRUD\nasync function upsertSchedule(record) {\n    const db = await getDB();\n    const tx = db.transaction('schedules', 'readwrite');\n    await tx.objectStore('schedules').put(record);\n    await tx.done;\n}\nasync function getAllSchedules() {\n    const db = await getDB();\n    return db.getAll('schedules');\n}\nasync function getScheduleByProblemId(problemId) {\n    const db = await getDB();\n    return db.get('schedules', problemId);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9kYi50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErQztBQTBCL0MsSUFBSUMsWUFBbUQ7QUFFaEQsZUFBZUM7SUFDcEIsSUFBSSxDQUFDRCxXQUFXO1FBQ2RBLFlBQVlELDJDQUFNQSxDQUFDLFlBQVksR0FBRztZQUNoQ0csU0FBUUMsRUFBRTtnQkFDUixJQUFJLENBQUNBLEdBQUdDLGdCQUFnQixDQUFDQyxRQUFRLENBQUMsYUFBYTtvQkFDN0MsTUFBTUMsV0FBV0gsR0FBR0ksaUJBQWlCLENBQUMsWUFBWTt3QkFBRUMsU0FBUztvQkFBSztvQkFDbEVGLFNBQVNHLFdBQVcsQ0FBQyxnQkFBZ0I7Z0JBQ3ZDO2dCQUNBLElBQUksQ0FBQ04sR0FBR0MsZ0JBQWdCLENBQUNDLFFBQVEsQ0FBQyxjQUFjO29CQUM5QyxNQUFNSyxZQUFZUCxHQUFHSSxpQkFBaUIsQ0FBQyxhQUFhO3dCQUFFQyxTQUFTO29CQUFZO29CQUMzRUUsVUFBVUQsV0FBVyxDQUFDLGdCQUFnQjtnQkFDeEM7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPVDtBQUNUO0FBRUEsZ0JBQWdCO0FBQ1QsZUFBZVcsWUFBWUMsT0FBd0I7SUFDeEQsTUFBTVQsS0FBSyxNQUFNRjtJQUNqQixNQUFNWSxLQUFLLEdBQVlDLFdBQVcsQ0FBQyxZQUFZO0lBQy9DLE1BQU1DLFFBQVFGLEdBQUdHLFdBQVcsQ0FBQztJQUM3QixLQUFLLE1BQU1DLE9BQU9MLFFBQVM7UUFDekIsTUFBTUcsTUFBTUcsR0FBRyxDQUFDRDtJQUNsQjtJQUNBLE1BQU1KLEdBQUdNLElBQUk7QUFDZjtBQUVPLGVBQWVDO0lBQ3BCLE1BQU1qQixLQUFLLE1BQU1GO0lBQ2pCLE9BQU8sR0FBWW9CLE1BQU0sQ0FBQztBQUM1QjtBQUVPLGVBQWVDLGVBQWVDLEVBQVU7SUFDN0MsTUFBTXBCLEtBQUssTUFBTUY7SUFDakIsT0FBTyxHQUFZdUIsR0FBRyxDQUFDLFlBQVlEO0FBQ3JDO0FBRUEsaUJBQWlCO0FBQ1YsZUFBZUUsZUFBZUMsTUFBc0I7SUFDekQsTUFBTXZCLEtBQUssTUFBTUY7SUFDakIsTUFBTVksS0FBSyxHQUFZQyxXQUFXLENBQUMsYUFBYTtJQUNoRCxNQUFNRCxHQUFHRyxXQUFXLENBQUMsYUFBYUUsR0FBRyxDQUFDUTtJQUN0QyxNQUFNYixHQUFHTSxJQUFJO0FBQ2Y7QUFFTyxlQUFlUTtJQUNwQixNQUFNeEIsS0FBSyxNQUFNRjtJQUNqQixPQUFPLEdBQVlvQixNQUFNLENBQUM7QUFDNUI7QUFFTyxlQUFlTyx1QkFBdUJDLFNBQWlCO0lBQzVELE1BQU0xQixLQUFLLE1BQU1GO0lBQ2pCLE9BQU8sR0FBWXVCLEdBQUcsQ0FBQyxhQUFhSztBQUN0QyIsInNvdXJjZXMiOlsiL1VzZXJzL2RpZ2l0YWxmbG93ZXIvRGVza3RvcC9vcmJpcy9saWIvZGIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb3BlbkRCLCB0eXBlIElEQlBEYXRhYmFzZSB9IGZyb20gJ2lkYidcblxuZXhwb3J0IHR5cGUgUHJvYmxlbVJlY29yZCA9IHtcbiAgaWQ6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG4gIHByb21wdDogc3RyaW5nXG4gIGNvbnN0cmFpbnRzPzogc3RyaW5nXG4gIGV4YW1wbGVzPzogc3RyaW5nXG4gIHRhZ3M/OiBzdHJpbmdbXVxuICBzb3VyY2U/OiBzdHJpbmdcbiAgY3JlYXRlZEF0OiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgU2NoZWR1bGVSZWNvcmQgPSB7XG4gIHByb2JsZW1JZDogc3RyaW5nXG4gIG5leHREdWVBdDogbnVtYmVyXG4gIGxhc3RSYXRpbmc6IG51bWJlclxuICByYXRpbmdIaXN0b3J5OiBudW1iZXJbXVxuICBsZWVjaENvdW50OiBudW1iZXJcbiAgc25vb3plZFVudGlsPzogbnVtYmVyXG4gIGNyZWF0ZWRBdDogbnVtYmVyXG4gIHVwZGF0ZWRBdDogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIE9yYmlzREIgPSBJREJQRGF0YWJhc2U8dW5rbm93bj5cblxubGV0IGRiUHJvbWlzZTogUHJvbWlzZTxJREJQRGF0YWJhc2U8dW5rbm93bj4+IHwgbnVsbCA9IG51bGxcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERCKCk6IFByb21pc2U8SURCUERhdGFiYXNlPHVua25vd24+PiB7XG4gIGlmICghZGJQcm9taXNlKSB7XG4gICAgZGJQcm9taXNlID0gb3BlbkRCKCdvcmJpcy1kYicsIDEsIHtcbiAgICAgIHVwZ3JhZGUoZGIpIHtcbiAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdwcm9ibGVtcycpKSB7XG4gICAgICAgICAgY29uc3QgcHJvYmxlbXMgPSBkYi5jcmVhdGVPYmplY3RTdG9yZSgncHJvYmxlbXMnLCB7IGtleVBhdGg6ICdpZCcgfSlcbiAgICAgICAgICBwcm9ibGVtcy5jcmVhdGVJbmRleCgnYnlfY3JlYXRlZEF0JywgJ2NyZWF0ZWRBdCcpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdzY2hlZHVsZXMnKSkge1xuICAgICAgICAgIGNvbnN0IHNjaGVkdWxlcyA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdzY2hlZHVsZXMnLCB7IGtleVBhdGg6ICdwcm9ibGVtSWQnIH0pXG4gICAgICAgICAgc2NoZWR1bGVzLmNyZWF0ZUluZGV4KCdieV9uZXh0RHVlQXQnLCAnbmV4dER1ZUF0JylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KVxuICB9XG4gIHJldHVybiBkYlByb21pc2Vcbn1cblxuLy8gUHJvYmxlbXMgQ1JVRFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHB1dFByb2JsZW1zKHJlY29yZHM6IFByb2JsZW1SZWNvcmRbXSk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkYiA9IGF3YWl0IGdldERCKClcbiAgY29uc3QgdHggPSAoZGIgYXMgYW55KS50cmFuc2FjdGlvbigncHJvYmxlbXMnLCAncmVhZHdyaXRlJylcbiAgY29uc3Qgc3RvcmUgPSB0eC5vYmplY3RTdG9yZSgncHJvYmxlbXMnKVxuICBmb3IgKGNvbnN0IHJlYyBvZiByZWNvcmRzKSB7XG4gICAgYXdhaXQgc3RvcmUucHV0KHJlYylcbiAgfVxuICBhd2FpdCB0eC5kb25lXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxQcm9ibGVtcygpOiBQcm9taXNlPFByb2JsZW1SZWNvcmRbXT4ge1xuICBjb25zdCBkYiA9IGF3YWl0IGdldERCKClcbiAgcmV0dXJuIChkYiBhcyBhbnkpLmdldEFsbCgncHJvYmxlbXMnKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvYmxlbUJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8UHJvYmxlbVJlY29yZCB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBkYiA9IGF3YWl0IGdldERCKClcbiAgcmV0dXJuIChkYiBhcyBhbnkpLmdldCgncHJvYmxlbXMnLCBpZClcbn1cblxuLy8gU2NoZWR1bGVzIENSVURcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cHNlcnRTY2hlZHVsZShyZWNvcmQ6IFNjaGVkdWxlUmVjb3JkKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGRiID0gYXdhaXQgZ2V0REIoKVxuICBjb25zdCB0eCA9IChkYiBhcyBhbnkpLnRyYW5zYWN0aW9uKCdzY2hlZHVsZXMnLCAncmVhZHdyaXRlJylcbiAgYXdhaXQgdHgub2JqZWN0U3RvcmUoJ3NjaGVkdWxlcycpLnB1dChyZWNvcmQpXG4gIGF3YWl0IHR4LmRvbmVcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFNjaGVkdWxlcygpOiBQcm9taXNlPFNjaGVkdWxlUmVjb3JkW10+IHtcbiAgY29uc3QgZGIgPSBhd2FpdCBnZXREQigpXG4gIHJldHVybiAoZGIgYXMgYW55KS5nZXRBbGwoJ3NjaGVkdWxlcycpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTY2hlZHVsZUJ5UHJvYmxlbUlkKHByb2JsZW1JZDogc3RyaW5nKTogUHJvbWlzZTxTY2hlZHVsZVJlY29yZCB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBkYiA9IGF3YWl0IGdldERCKClcbiAgcmV0dXJuIChkYiBhcyBhbnkpLmdldCgnc2NoZWR1bGVzJywgcHJvYmxlbUlkKVxufVxuIl0sIm5hbWVzIjpbIm9wZW5EQiIsImRiUHJvbWlzZSIsImdldERCIiwidXBncmFkZSIsImRiIiwib2JqZWN0U3RvcmVOYW1lcyIsImNvbnRhaW5zIiwicHJvYmxlbXMiLCJjcmVhdGVPYmplY3RTdG9yZSIsImtleVBhdGgiLCJjcmVhdGVJbmRleCIsInNjaGVkdWxlcyIsInB1dFByb2JsZW1zIiwicmVjb3JkcyIsInR4IiwidHJhbnNhY3Rpb24iLCJzdG9yZSIsIm9iamVjdFN0b3JlIiwicmVjIiwicHV0IiwiZG9uZSIsImdldEFsbFByb2JsZW1zIiwiZ2V0QWxsIiwiZ2V0UHJvYmxlbUJ5SWQiLCJpZCIsImdldCIsInVwc2VydFNjaGVkdWxlIiwicmVjb3JkIiwiZ2V0QWxsU2NoZWR1bGVzIiwiZ2V0U2NoZWR1bGVCeVByb2JsZW1JZCIsInByb2JsZW1JZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/db.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/idb/build/index.js":
/*!*****************************************!*\
  !*** ./node_modules/idb/build/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: () => (/* binding */ deleteDB),\n/* harmony export */   openDB: () => (/* binding */ openDB),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUNBQXlDLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVSxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFeUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kaWdpdGFsZmxvd2VyL0Rlc2t0b3Avb3JiaXMvbm9kZV9tb2R1bGVzL2lkYi9idWlsZC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbnN0YW5jZU9mQW55ID0gKG9iamVjdCwgY29uc3RydWN0b3JzKSA9PiBjb25zdHJ1Y3RvcnMuc29tZSgoYykgPT4gb2JqZWN0IGluc3RhbmNlb2YgYyk7XG5cbmxldCBpZGJQcm94eWFibGVUeXBlcztcbmxldCBjdXJzb3JBZHZhbmNlTWV0aG9kcztcbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0SWRiUHJveHlhYmxlVHlwZXMoKSB7XG4gICAgcmV0dXJuIChpZGJQcm94eWFibGVUeXBlcyB8fFxuICAgICAgICAoaWRiUHJveHlhYmxlVHlwZXMgPSBbXG4gICAgICAgICAgICBJREJEYXRhYmFzZSxcbiAgICAgICAgICAgIElEQk9iamVjdFN0b3JlLFxuICAgICAgICAgICAgSURCSW5kZXgsXG4gICAgICAgICAgICBJREJDdXJzb3IsXG4gICAgICAgICAgICBJREJUcmFuc2FjdGlvbixcbiAgICAgICAgXSkpO1xufVxuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpIHtcbiAgICByZXR1cm4gKGN1cnNvckFkdmFuY2VNZXRob2RzIHx8XG4gICAgICAgIChjdXJzb3JBZHZhbmNlTWV0aG9kcyA9IFtcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuYWR2YW5jZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWUsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlUHJpbWFyeUtleSxcbiAgICAgICAgXSkpO1xufVxuY29uc3QgdHJhbnNhY3Rpb25Eb25lTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJldmVyc2VUcmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBwcm9taXNpZnlSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUod3JhcChyZXF1ZXN0LnJlc3VsdCkpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QocmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcbiAgICAvLyBUaGlzIG1hcHBpbmcgZXhpc3RzIGluIHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBidXQgZG9lc24ndCBleGlzdCBpbiB0cmFuc2Zvcm1DYWNoZS4gVGhpc1xuICAgIC8vIGlzIGJlY2F1c2Ugd2UgY3JlYXRlIG1hbnkgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0LlxuICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQocHJvbWlzZSwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odHgpIHtcbiAgICAvLyBFYXJseSBiYWlsIGlmIHdlJ3ZlIGFscmVhZHkgY3JlYXRlZCBhIGRvbmUgcHJvbWlzZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICBpZiAodHJhbnNhY3Rpb25Eb25lTWFwLmhhcyh0eCkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBkb25lID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdCh0eC5lcnJvciB8fCBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydEVycm9yJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGNvbXBsZXRlKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgIH0pO1xuICAgIC8vIENhY2hlIGl0IGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAgdHJhbnNhY3Rpb25Eb25lTWFwLnNldCh0eCwgZG9uZSk7XG59XG5sZXQgaWRiUHJveHlUcmFwcyA9IHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyYW5zYWN0aW9uLmRvbmUuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2RvbmUnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkRvbmVNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICAvLyBNYWtlIHR4LnN0b3JlIHJldHVybiB0aGUgb25seSBzdG9yZSBpbiB0aGUgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbWFueS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnc3RvcmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiByZWNlaXZlci5vYmplY3RTdG9yZShyZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHRyYW5zZm9ybSB3aGF0ZXZlciB3ZSBnZXQgYmFjay5cbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0W3Byb3BdKTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uICYmXG4gICAgICAgICAgICAocHJvcCA9PT0gJ2RvbmUnIHx8IHByb3AgPT09ICdzdG9yZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcCBpbiB0YXJnZXQ7XG4gICAgfSxcbn07XG5mdW5jdGlvbiByZXBsYWNlVHJhcHMoY2FsbGJhY2spIHtcbiAgICBpZGJQcm94eVRyYXBzID0gY2FsbGJhY2soaWRiUHJveHlUcmFwcyk7XG59XG5mdW5jdGlvbiB3cmFwRnVuY3Rpb24oZnVuYykge1xuICAgIC8vIER1ZSB0byBleHBlY3RlZCBvYmplY3QgZXF1YWxpdHkgKHdoaWNoIGlzIGVuZm9yY2VkIGJ5IHRoZSBjYWNoaW5nIGluIGB3cmFwYCksIHdlXG4gICAgLy8gb25seSBjcmVhdGUgb25lIG5ldyBmdW5jIHBlciBmdW5jLlxuICAgIC8vIEN1cnNvciBtZXRob2RzIGFyZSBzcGVjaWFsLCBhcyB0aGUgYmVoYXZpb3VyIGlzIGEgbGl0dGxlIG1vcmUgZGlmZmVyZW50IHRvIHN0YW5kYXJkIElEQi4gSW5cbiAgICAvLyBJREIsIHlvdSBhZHZhbmNlIHRoZSBjdXJzb3IgYW5kIHdhaXQgZm9yIGEgbmV3ICdzdWNjZXNzJyBvbiB0aGUgSURCUmVxdWVzdCB0aGF0IGdhdmUgeW91IHRoZVxuICAgIC8vIGN1cnNvci4gSXQncyBraW5kYSBsaWtlIGEgcHJvbWlzZSB0aGF0IGNhbiByZXNvbHZlIHdpdGggbWFueSB2YWx1ZXMuIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgLy8gd2l0aCByZWFsIHByb21pc2VzLCBzbyBlYWNoIGFkdmFuY2UgbWV0aG9kcyByZXR1cm5zIGEgbmV3IHByb21pc2UgZm9yIHRoZSBjdXJzb3Igb2JqZWN0LCBvclxuICAgIC8vIHVuZGVmaW5lZCBpZiB0aGUgZW5kIG9mIHRoZSBjdXJzb3IgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICBpZiAoZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKS5pbmNsdWRlcyhmdW5jKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3h5IGFzICd0aGlzJyBjYXVzZXMgSUxMRUdBTCBJTlZPQ0FUSU9OLCBzbyB3ZSB1c2VcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgICAgICBmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcCh0aGlzLnJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICByZXR1cm4gd3JhcChmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncykpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbih2YWx1ZSk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHJldHVybiwgaXQganVzdCBjcmVhdGVzIGEgJ2RvbmUnIHByb21pc2UgZm9yIHRoZSB0cmFuc2FjdGlvbixcbiAgICAvLyB3aGljaCBpcyBsYXRlciByZXR1cm5lZCBmb3IgdHJhbnNhY3Rpb24uZG9uZSAoc2VlIGlkYk9iamVjdEhhbmRsZXIpLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKVxuICAgICAgICBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odmFsdWUpO1xuICAgIGlmIChpbnN0YW5jZU9mQW55KHZhbHVlLCBnZXRJZGJQcm94eWFibGVUeXBlcygpKSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh2YWx1ZSwgaWRiUHJveHlUcmFwcyk7XG4gICAgLy8gUmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2sgaWYgd2UncmUgbm90IGdvaW5nIHRvIHRyYW5zZm9ybSBpdC5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgLy8gV2Ugc29tZXRpbWVzIGdlbmVyYXRlIG11bHRpcGxlIHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdCAoZWcgd2hlbiBjdXJzb3JpbmcpLCBiZWNhdXNlXG4gICAgLy8gSURCIGlzIHdlaXJkIGFuZCBhIHNpbmdsZSBJREJSZXF1ZXN0IGNhbiB5aWVsZCBtYW55IHJlc3BvbnNlcywgc28gdGhlc2UgY2FuJ3QgYmUgY2FjaGVkLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlJlcXVlc3QpXG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHZhbHVlKTtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHRyYW5zZm9ybWVkIHRoaXMgdmFsdWUgYmVmb3JlLCByZXVzZSB0aGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gICAgLy8gVGhpcyBpcyBmYXN0ZXIsIGJ1dCBpdCBhbHNvIHByb3ZpZGVzIG9iamVjdCBlcXVhbGl0eS5cbiAgICBpZiAodHJhbnNmb3JtQ2FjaGUuaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKTtcbiAgICAvLyBOb3QgYWxsIHR5cGVzIGFyZSB0cmFuc2Zvcm1lZC5cbiAgICAvLyBUaGVzZSBtYXkgYmUgcHJpbWl0aXZlIHR5cGVzLCBzbyB0aGV5IGNhbid0IGJlIFdlYWtNYXAga2V5cy5cbiAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRyYW5zZm9ybUNhY2hlLnNldCh2YWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KG5ld1ZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmNvbnN0IHVud3JhcCA9ICh2YWx1ZSkgPT4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG5cbi8qKlxuICogT3BlbiBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICogQHBhcmFtIHZlcnNpb24gU2NoZW1hIHZlcnNpb24uXG4gKiBAcGFyYW0gY2FsbGJhY2tzIEFkZGl0aW9uYWwgY2FsbGJhY2tzLlxuICovXG5mdW5jdGlvbiBvcGVuREIobmFtZSwgdmVyc2lvbiwgeyBibG9ja2VkLCB1cGdyYWRlLCBibG9ja2luZywgdGVybWluYXRlZCB9ID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4obmFtZSwgdmVyc2lvbik7XG4gICAgY29uc3Qgb3BlblByb21pc2UgPSB3cmFwKHJlcXVlc3QpO1xuICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigndXBncmFkZW5lZWRlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdXBncmFkZSh3cmFwKHJlcXVlc3QucmVzdWx0KSwgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgd3JhcChyZXF1ZXN0LnRyYW5zYWN0aW9uKSwgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJsb2NrZWQpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKGV2ZW50KSA9PiBibG9ja2VkKFxuICAgICAgICAvLyBDYXN0aW5nIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNDA1XG4gICAgICAgIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIGV2ZW50KSk7XG4gICAgfVxuICAgIG9wZW5Qcm9taXNlXG4gICAgICAgIC50aGVuKChkYikgPT4ge1xuICAgICAgICBpZiAodGVybWluYXRlZClcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4gdGVybWluYXRlZCgpKTtcbiAgICAgICAgaWYgKGJsb2NraW5nKSB7XG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCd2ZXJzaW9uY2hhbmdlJywgKGV2ZW50KSA9PiBibG9ja2luZyhldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCBldmVudCkpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgcmV0dXJuIG9wZW5Qcm9taXNlO1xufVxuLyoqXG4gKiBEZWxldGUgYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlREIobmFtZSwgeyBibG9ja2VkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XG4gICAgaWYgKGJsb2NrZWQpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKGV2ZW50KSA9PiBibG9ja2VkKFxuICAgICAgICAvLyBDYXN0aW5nIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNDA1XG4gICAgICAgIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50KSk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwKHJlcXVlc3QpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbn1cblxuY29uc3QgcmVhZE1ldGhvZHMgPSBbJ2dldCcsICdnZXRLZXknLCAnZ2V0QWxsJywgJ2dldEFsbEtleXMnLCAnY291bnQnXTtcbmNvbnN0IHdyaXRlTWV0aG9kcyA9IFsncHV0JywgJ2FkZCcsICdkZWxldGUnLCAnY2xlYXInXTtcbmNvbnN0IGNhY2hlZE1ldGhvZHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB7XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSURCRGF0YWJhc2UgJiZcbiAgICAgICAgIShwcm9wIGluIHRhcmdldCkgJiZcbiAgICAgICAgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYWNoZWRNZXRob2RzLmdldChwcm9wKSlcbiAgICAgICAgcmV0dXJuIGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApO1xuICAgIGNvbnN0IHRhcmdldEZ1bmNOYW1lID0gcHJvcC5yZXBsYWNlKC9Gcm9tSW5kZXgkLywgJycpO1xuICAgIGNvbnN0IHVzZUluZGV4ID0gcHJvcCAhPT0gdGFyZ2V0RnVuY05hbWU7XG4gICAgY29uc3QgaXNXcml0ZSA9IHdyaXRlTWV0aG9kcy5pbmNsdWRlcyh0YXJnZXRGdW5jTmFtZSk7XG4gICAgaWYgKFxuICAgIC8vIEJhaWwgaWYgdGhlIHRhcmdldCBkb2Vzbid0IGV4aXN0IG9uIHRoZSB0YXJnZXQuIEVnLCBnZXRBbGwgaXNuJ3QgaW4gRWRnZS5cbiAgICAhKHRhcmdldEZ1bmNOYW1lIGluICh1c2VJbmRleCA/IElEQkluZGV4IDogSURCT2JqZWN0U3RvcmUpLnByb3RvdHlwZSkgfHxcbiAgICAgICAgIShpc1dyaXRlIHx8IHJlYWRNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyBmdW5jdGlvbiAoc3RvcmVOYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6IHVuZGVmaW5lZCBnemlwcHMgYmV0dGVyLCBidXQgZmFpbHMgaW4gRWRnZSA6KFxuICAgICAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCBpc1dyaXRlID8gJ3JlYWR3cml0ZScgOiAncmVhZG9ubHknKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHR4LnN0b3JlO1xuICAgICAgICBpZiAodXNlSW5kZXgpXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaW5kZXgoYXJncy5zaGlmdCgpKTtcbiAgICAgICAgLy8gTXVzdCByZWplY3QgaWYgb3AgcmVqZWN0cy5cbiAgICAgICAgLy8gSWYgaXQncyBhIHdyaXRlIG9wZXJhdGlvbiwgbXVzdCByZWplY3QgaWYgdHguZG9uZSByZWplY3RzLlxuICAgICAgICAvLyBNdXN0IHJlamVjdCB3aXRoIG9wIHJlamVjdGlvbiBmaXJzdC5cbiAgICAgICAgLy8gTXVzdCByZXNvbHZlIHdpdGggb3AgdmFsdWUuXG4gICAgICAgIC8vIE11c3QgaGFuZGxlIGJvdGggcHJvbWlzZXMgKG5vIHVuaGFuZGxlZCByZWplY3Rpb25zKVxuICAgICAgICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRhcmdldFt0YXJnZXRGdW5jTmFtZV0oLi4uYXJncyksXG4gICAgICAgICAgICBpc1dyaXRlICYmIHR4LmRvbmUsXG4gICAgICAgIF0pKVswXTtcbiAgICB9O1xuICAgIGNhY2hlZE1ldGhvZHMuc2V0KHByb3AsIG1ldGhvZCk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XG4gICAgLi4ub2xkVHJhcHMsXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4gZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpLFxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gISFnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKSxcbn0pKTtcblxuY29uc3QgYWR2YW5jZU1ldGhvZFByb3BzID0gWydjb250aW51ZScsICdjb250aW51ZVByaW1hcnlLZXknLCAnYWR2YW5jZSddO1xuY29uc3QgbWV0aG9kTWFwID0ge307XG5jb25zdCBhZHZhbmNlUmVzdWx0cyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBpdHRyUHJveGllZEN1cnNvclRvT3JpZ2luYWxQcm94eSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBjdXJzb3JJdGVyYXRvclRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKCFhZHZhbmNlTWV0aG9kUHJvcHMuaW5jbHVkZXMocHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICBsZXQgY2FjaGVkRnVuYyA9IG1ldGhvZE1hcFtwcm9wXTtcbiAgICAgICAgaWYgKCFjYWNoZWRGdW5jKSB7XG4gICAgICAgICAgICBjYWNoZWRGdW5jID0gbWV0aG9kTWFwW3Byb3BdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlUmVzdWx0cy5zZXQodGhpcywgaXR0clByb3hpZWRDdXJzb3JUb09yaWdpbmFsUHJveHkuZ2V0KHRoaXMpW3Byb3BdKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZEZ1bmM7XG4gICAgfSxcbn07XG5hc3luYyBmdW5jdGlvbiogaXRlcmF0ZSguLi5hcmdzKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXRoaXMtYXNzaWdubWVudFxuICAgIGxldCBjdXJzb3IgPSB0aGlzO1xuICAgIGlmICghKGN1cnNvciBpbnN0YW5jZW9mIElEQkN1cnNvcikpIHtcbiAgICAgICAgY3Vyc29yID0gYXdhaXQgY3Vyc29yLm9wZW5DdXJzb3IoLi4uYXJncyk7XG4gICAgfVxuICAgIGlmICghY3Vyc29yKVxuICAgICAgICByZXR1cm47XG4gICAgY3Vyc29yID0gY3Vyc29yO1xuICAgIGNvbnN0IHByb3hpZWRDdXJzb3IgPSBuZXcgUHJveHkoY3Vyc29yLCBjdXJzb3JJdGVyYXRvclRyYXBzKTtcbiAgICBpdHRyUHJveGllZEN1cnNvclRvT3JpZ2luYWxQcm94eS5zZXQocHJveGllZEN1cnNvciwgY3Vyc29yKTtcbiAgICAvLyBNYXAgdGhpcyBkb3VibGUtcHJveHkgYmFjayB0byB0aGUgb3JpZ2luYWwsIHNvIG90aGVyIGN1cnNvciBtZXRob2RzIHdvcmsuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm94aWVkQ3Vyc29yLCB1bndyYXAoY3Vyc29yKSk7XG4gICAgd2hpbGUgKGN1cnNvcikge1xuICAgICAgICB5aWVsZCBwcm94aWVkQ3Vyc29yO1xuICAgICAgICAvLyBJZiBvbmUgb2YgdGhlIGFkdmFuY2luZyBtZXRob2RzIHdhcyBub3QgY2FsbGVkLCBjYWxsIGNvbnRpbnVlKCkuXG4gICAgICAgIGN1cnNvciA9IGF3YWl0IChhZHZhbmNlUmVzdWx0cy5nZXQocHJveGllZEN1cnNvcikgfHwgY3Vyc29yLmNvbnRpbnVlKCkpO1xuICAgICAgICBhZHZhbmNlUmVzdWx0cy5kZWxldGUocHJveGllZEN1cnNvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNJdGVyYXRvclByb3AodGFyZ2V0LCBwcm9wKSB7XG4gICAgcmV0dXJuICgocHJvcCA9PT0gU3ltYm9sLmFzeW5jSXRlcmF0b3IgJiZcbiAgICAgICAgaW5zdGFuY2VPZkFueSh0YXJnZXQsIFtJREJJbmRleCwgSURCT2JqZWN0U3RvcmUsIElEQkN1cnNvcl0pKSB8fFxuICAgICAgICAocHJvcCA9PT0gJ2l0ZXJhdGUnICYmIGluc3RhbmNlT2ZBbnkodGFyZ2V0LCBbSURCSW5kZXgsIElEQk9iamVjdFN0b3JlXSkpKTtcbn1cbnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XG4gICAgLi4ub2xkVHJhcHMsXG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKGlzSXRlcmF0b3JQcm9wKHRhcmdldCwgcHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0ZTtcbiAgICAgICAgcmV0dXJuIG9sZFRyYXBzLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGlzSXRlcmF0b3JQcm9wKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgfSxcbn0pKTtcblxuZXhwb3J0IHsgZGVsZXRlREIsIG9wZW5EQiwgdW53cmFwLCB3cmFwIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/idb/build/index.js\n"));

/***/ })

});